<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blackjack – GamLearn</title>
  <link rel="stylesheet" href="dist/styles/style.css" />
  <link rel="icon" type="image/png" href="dist/img/Gemini_Generated_Image_a90d7va90d7va90d.png">
  <style>
    :root{
      --bj-felt:#0b3b2d;
      --accent:#6ccfff;
      --stroke:rgba(255,255,255,0.09);
    }
    body{background: #0e1118;}
    .bj-wrap{
      min-height: 100dvh;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    /* Topbar */
    .bj-topbar{
      position: sticky; top: 0; z-index: 20;
      display:flex; align-items:center; gap:10px;
      padding:10px 14px; border-bottom:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(16,16,24,.85), rgba(16,16,24,.6));
      backdrop-filter: blur(10px);
    }
    .bj-topbar a{
      text-decoration:none; color:#fff;
      border:1px solid var(--stroke); border-radius:999px;
      padding:6px 12px; background: rgba(255,255,255,.06);
      font-weight:800;
      transition: background-color .15s ease, transform .03s ease;
    }
    .bj-topbar a:hover{background: rgba(255,255,255,.1)}
    .bj-topbar a:active{transform: translateY(1px)}
    .bj-title{margin-left:auto; margin-right:auto; color:#fff; font-weight:900; letter-spacing:.3px}
    /* Stół */
    .bj-table{
      display:grid;
      grid-template-rows: auto 1fr auto auto;
      gap: 14px;
      max-width: 1100px;
      margin: 18px auto 28px;
      padding: 18px;
      border:1px solid var(--stroke);
      border-radius: 18px;
      background:
        radial-gradient(900px 450px at 10% -10%, rgba(108,204,255,.14), transparent 60%),
        radial-gradient(900px 450px at 90% 120%, rgba(167,139,250,.12), transparent 60%),
        linear-gradient(180deg, rgba(16,16,24,.65), rgba(16,16,24,.75)),
        radial-gradient(circle at 50% 50%, rgba(0,0,0,.2), rgba(0,0,0,0) 60%),
        var(--bj-felt);
      color:#fff;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    .row{display:grid; gap:10px}
    .row.dealer, .row.player{justify-items:center}
    .row h3{
      margin:0; font-weight:900; letter-spacing:.4px;
      background: linear-gradient(90deg, #fff, #cfe9ff);
      -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
      text-shadow: 0 0 18px rgba(108,204,255,.18);
    }
    .hand{
      display:flex; align-items:flex-end; gap:10px; flex-wrap:wrap;
      min-height: 120px;
    }
    /* Karty */
    .card{
      width: 88px; height: 124px; border-radius: 12px;
      background: #fdfdfd;
      border: 1px solid rgba(0,0,0,.15);
      box-shadow: 0 10px 26px rgba(0,0,0,.35);
      position: relative; overflow: hidden;
      transform: translateY(10px) scale(.98);
      opacity: 0; animation: cardIn .35s cubic-bezier(.2,.75,.25,1) forwards;
    }
    @keyframes cardIn { to { opacity:1; transform:none; } }
    .card.red{ color:#c01b39; }
    .card.black{ color:#111; }
    .card .corner{
      position:absolute; font-weight:900;
      font-size: 18px; line-height:1;
    }
    .card .tl{ top:8px; left:10px; text-align:left; }
    .card .br{ bottom:8px; right:10px; text-align:right; rotate: 180deg; }
    .card .pip{
      position:absolute; inset: 34px 12px 12px 12px;
      display:grid; place-items:center;
      font-size: 34px;
    }
    /* Zakryta karta */
    .card.back{
      background: repeating-linear-gradient(45deg, #122, #122 10px, #0d1b2a 10px, #0d1b2a 20px);
      display:grid; place-items:center;
      color:#8fd3ff; font-weight:900; letter-spacing:.4px;
    }
    .score-badge{
      border:1px solid var(--stroke); border-radius:10px; padding:4px 8px;
      background: rgba(255,255,255,.06);
      font-weight:800;
    }
    /* Panel stawek i sterowania */
    .panel{
      display:grid; gap:10px;
      grid-template-columns: 1fr;
    }
    .chips{
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
    }
    .chip{
      border-radius:999px; padding:6px 10px; cursor:pointer;
      border:1px solid var(--stroke); background: rgba(255,255,255,.08);
      box-shadow: 0 8px 20px rgba(0,0,0,.35);
      font-weight:800; transition: transform .03s ease, background-color .15s ease;
    }
    .chip:hover{ background: rgba(255,255,255,.12) }
    .chip:active{ transform: translateY(1px) }
    .wallet{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      border:1px solid var(--stroke); border-radius:12px;
      padding:10px; background: rgba(255,255,255,.06);
    }
    .controls{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center;
    }
    .btn{
      border:1px solid var(--stroke); border-radius:12px; padding:10px 14px;
      background: rgba(255,255,255,.08); color:#fff; font-weight:900; letter-spacing:.3px;
      cursor:pointer; transition: background-color .15s ease, transform .03s ease, filter .15s ease;
      box-shadow: 0 10px 26px rgba(0,0,0,.35);
    }
    .btn.primary{ background: linear-gradient(135deg, #6cf, #9df); color:#001018; border:0; }
    .btn:hover{ filter: brightness(1.05); }
    .btn:active{ transform: translateY(1px); }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .msg{
      text-align:center; font-weight:800; letter-spacing:.3px;
      padding:10px; border-radius:10px; border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      min-height: 40px;
    }
    .payout{ color:#16e0a9; }
    .lose{ color:#ff8080; }
    .push{ color:#9fd7ff; }
    /* Ubezpieczenie – panel szkło + neon */
    .insurance-panel{
      display:grid; gap:10px; align-items:center; justify-items:center;
      padding:12px; border-radius:14px; border:1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
    }
    .insurance-panel[hidden]{ display:none; }
    .insurance-panel .ins-text{
      text-align:center; color:#fff; font-weight:800; letter-spacing:.3px;
    }
    .insurance-panel .ins-actions{ display:flex; gap:10px; flex-wrap:wrap; }
    .btn-ins{
      border:1px solid var(--stroke); border-radius:12px; padding:10px 14px;
      background: rgba(255,255,255,.08); color:#fff; font-weight:900; letter-spacing:.3px;
      cursor:pointer; transition: background-color .15s ease, transform .03s ease, filter .15s ease;
      box-shadow: 0 10px 26px rgba(0,0,0,.35);
    }
    .btn-ins.primary{ background: linear-gradient(135deg, #6cf, #9df); color:#001018; border:0; }
    .btn-ins:hover{ filter: brightness(1.05); }
    .btn-ins:active{ transform: translateY(1px) }
    /* Ręce po splicie – kapsułki i podświetlenie aktywnej */
    .phand {
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 8px 10px;
      background: rgba(255,255,255,.04);
      box-shadow: 0 10px 26px rgba(0,0,0,.25) inset;
      margin: 6px 2px;
    }
    .phand.active {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
      background: rgba(255,255,255,.06);
    }
    .phand .phand-title {
      display: flex; gap: 8px; align-items: center; justify-content: center;
      font-weight: 900; letter-spacing: .3px; margin-bottom: 6px; color: #fff;
    }
    @media (min-width: 860px){
      .panel{ grid-template-columns: 1fr auto; align-items:center; }
    }
  </style>
</head>
<body>
  <div class="bj-wrap">
    <div class="bj-topbar">
      <a href="index.html">← Strona główna</a>
      <a href="consequence.html">Konsekwencje</a>
      <div class="bj-title">Blackjack</div>
    </div>

    <main class="bj-table">
      <div class="row dealer">
        <h3>Krupier <span id="dealerScore" class="score-badge">0</span></h3>
        <div id="dealerHand" class="hand" aria-live="polite"></div>
      </div>

      <div class="row player">
        <h3>Gracz <span id="playerScore" class="score-badge">0</span></h3>
        <div id="playerHand" class="hand" aria-live="polite"></div>
      </div>

      <div class="panel">
        <div class="wallet">
          <div>Saldo: <strong id="balance">0</strong> żetonów</div>
          <div>Zakład: <strong id="bet">0</strong></div>
        </div>
        <div class="chips">
          <button class="chip" data-add="5">+5</button>
          <button class="chip" data-add="10">+10</button>
          <button class="chip" data-add="25">+25</button>
          <button class="chip" data-add="50">+50</button>
          <button class="chip" data-add="100">+100</button>
          <button class="chip" data-clear="1">Wyczyść</button>
        </div>
      </div>

      <div class="controls">
        <button id="dealBtn" class="btn primary">Rozdaj</button>
        <button id="hitBtn" class="btn" disabled>Dobierz (H)</button>
        <button id="standBtn" class="btn" disabled>Stój (S)</button>
        <button id="doubleBtn" class="btn" disabled>Podwój (D)</button>
        <button id="splitBtn" class="btn" disabled>Split (P)</button>
        <button id="newBtn" class="btn" disabled>Nowa runda</button>
      </div>

      <div id="message" class="msg"></div>

      <!-- Panel ubezpieczenia: pokaże się tylko przy Asie krupiera -->
      <div id="insurancePanel" class="insurance-panel" hidden>
        <div class="ins-text">Karta krupiera to As. Ubezpieczyć zakład? (50% stawki, wypłata 2:1 przy blackjacku krupiera)</div>
        <div class="ins-actions">
          <button id="insYes" class="btn-ins primary" type="button">Ubezpiecz</button>
          <button id="insNo" class="btn-ins" type="button">Bez ubezpieczenia</button>
        </div>
      </div>
    </main>

    <footer style="text-align:center; padding:14px; color:#9fb3c8;">Powodzenia! Graj odpowiedzialnie.</footer>
  </div>

  <script>
    // Logika Blackjack
    const dealerHandEl = document.getElementById('dealerHand');
    const playerHandEl = document.getElementById('playerHand');
    const dealerScoreEl = document.getElementById('dealerScore');
    const playerScoreEl = document.getElementById('playerScore');
    const messageEl = document.getElementById('message');

    const dealBtn = document.getElementById('dealBtn');
    const hitBtn = document.getElementById('hitBtn');
    const standBtn = document.getElementById('standBtn');
    const doubleBtn = document.getElementById('doubleBtn');
    const newBtn = document.getElementById('newBtn');
    const splitBtn = document.getElementById('splitBtn');

    const balanceEl = document.getElementById('balance');
    const betEl = document.getElementById('bet');

    const chips = Array.from(document.querySelectorAll('.chip'));

    const SUITS = ['♠','♥','♦','♣'];
    const VALUES = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

    let deck = [];
    let dealer = [];
    let player = [];
    let splitActive = false;
    let playerHands = null;
    let handBets = null;
    let currentHand = 0;
    let hiddenDealerCard = null;
    let hideDealerHole = true;

    // === Split helpers (para o tej samej wartości; 10/J/Q/K traktowane jako 10) ===
    function currentPlayerHand(){
      return splitActive ? (playerHands && playerHands[currentHand] ? playerHands[currentHand] : []) : player;
    }
    function sameValue(a, b){
      if (!a || !b) return false;
      // porównaj wartości punktowe (10=J=Q=K)
      return cardValue(a.v) === cardValue(b.v);
    }
    const MAX_HANDS = 4;
    function canSplit(){
      if (state !== 'player') return false;
      const hand = currentPlayerHand();
      if (hand.length !== 2) return false;
      if (!sameValue(hand[0], hand[1])) return false;
      const need = splitActive ? (handBets ? handBets[currentHand] : 0) : bet;
      if (balance < need) return false;
      if (splitActive && playerHands && playerHands.length >= MAX_HANDS) return false;
      return true;
    }

    let balance = Number(localStorage.getItem('bj_balance') || 1000);
    let bet = 0;
    let state = 'betting'; // betting -> player -> dealer -> round-over

    function saveBalance(){ localStorage.setItem('bj_balance', String(balance)); }
    function updateMoney(){ balanceEl.textContent = balance; betEl.textContent = bet; }

    function createDeck(){
      deck = [];
      for (const s of SUITS){
        for (const v of VALUES){
          deck.push({s,v});
        }
      }
      // Shuffle - Fisher-Yates
      for (let i=deck.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }

    function cardValue(v){
      if (v === 'A') return 11;
      if (['K','Q','J'].includes(v)) return 10;
      return Number(v);
    }

    function handTotals(hand){
      let total = 0, aces = 0;
      for (const c of hand){
        total += cardValue(c.v);
        if (c.v === 'A') aces++;
      }
      // Redukcja Asów z 11 do 1
      while (total > 21 && aces > 0){
        total -= 10; aces--;
      }
      return total;
    }

    function renderHand(el, hand, isDealer){
      el.innerHTML = '';
      hand.forEach((c, idx) => {
        const card = document.createElement('div');
        const red = (c.s === '♥' || c.s === '♦');
        card.className = 'card ' + (red ? 'red':'black');
        if (isDealer && idx === 1 && hideDealerHole){
          card.className = 'card back';
          card.innerHTML = '<span>GAM</span>';
        } else {
          card.innerHTML = `
            <div class="corner tl">${c.v}<br>${c.s}</div>
            <div class="corner br">${c.v}<br>${c.s}</div>
            <div class="pip">${c.s}</div>
          `;
        }
        el.appendChild(card);
      });
    }

    // Render rąk gracza (pojedyncza lub wiele)
    function renderPlayer(){
      if (!splitActive){
        renderHand(playerHandEl, player, false);
        return;
      }
      playerHandEl.innerHTML = '';
      playerHands.forEach((hand, i) => {
        const wrap = document.createElement('div');
        wrap.className = 'phand' + (i === currentHand ? ' active' : '');
        const title = document.createElement('div');
        title.className = 'phand-title';
        title.innerHTML = `Ręka ${i+1} <span class="score-badge">${handTotals(hand)}</span>`;
        const lane = document.createElement('div');
        lane.className = 'hand';
        renderHand(lane, hand, false);
        wrap.appendChild(title);
        wrap.appendChild(lane);
        playerHandEl.appendChild(wrap);
      });
    }

    // 1) Pokaż sumę tylko gdy karta krupiera odkryta
    function updateScores(){
      const dTotal = handTotals(dealer);
      const pTotal = handTotals(currentPlayerHand());
      const dealerShown = hideDealerHole
        ? (dealer.length ? cardValue(dealer[0].v) : 0)
        : dTotal;

      dealerScoreEl.textContent = dealerShown;
      playerScoreEl.textContent = pTotal;
      return { d: dTotal, p: pTotal };
    }

    function setMsg(text, cls=''){
      messageEl.className = 'msg ' + cls;
      messageEl.textContent = text;
    }

    // Ubezpieczenie – stan i elementy
    let insuranceBet = 0;
    let insuranceTaken = false;
    let insuranceOffered = false;

    const insPanel = document.getElementById('insurancePanel');
    const insYes   = document.getElementById('insYes');
    const insNo    = document.getElementById('insNo');

    function showInsurance(show){ if (insPanel) insPanel.hidden = !show; }

    // Nadpisanie setControls: blokuj ruchy gracza podczas oferty ubezpieczenia
    function setControls(){
      dealBtn.disabled   = !(state === 'betting' && bet > 0 && balance >= bet);
      const pTurn = (state === 'player');
      const cur = currentPlayerHand();
      const pTotal = handTotals(cur);

      hitBtn.disabled    = !pTurn || pTotal >= 21;  // blokada przy 21
      standBtn.disabled  = !pTurn;

      if (!splitActive){
        doubleBtn.disabled = !(pTurn && player.length === 2 && balance >= bet) || pTotal >= 21; // blokada przy 21
      } else {
        doubleBtn.disabled = !(pTurn && cur.length === 2 && balance >= handBets[currentHand]) || pTotal >= 21; // blokada przy 21
      }

      splitBtn.disabled  = !canSplit();
      newBtn.disabled    = !(state === 'round-over');
    }

    function resetHands(){
      dealer = [];
      player = [];
      // reset split
      splitActive = false;
      playerHands = null;
      handBets = null;
      currentHand = 0;
      hiddenDealerCard = null;
      hideDealerHole = true;
      renderHand(dealerHandEl, dealer, true);
      renderPlayer();
      updateScores();
    }

    // Start rozdania – z ofertą ubezpieczenia przy Asie
    function startRound(){
      if (bet <= 0 || balance < bet) return;
      state = 'dealt';
      balance -= bet; saveBalance(); updateMoney();
      createDeck();
      resetHands();

      // Rozdanie
      player.push(deck.pop());
      dealer.push(deck.pop());
      player.push(deck.pop());
      hiddenDealerCard = deck.pop();
      dealer.push(hiddenDealerCard);

      renderPlayer();
      renderHand(dealerHandEl, dealer, true);
      updateScores();

      // Oferta ubezpieczenia, gdy As na wierzchu
      const pTotal = handTotals(player);
      if (dealer[0].v === 'A'){
        state = 'insurance';
        insuranceOffered = true;
        showInsurance(true);
        setMsg('Dealer pokazuje Asa. Chcesz ubezpieczenie 50% stawki (wypłata 2:1)?');
        setControls();
        return; // poczekaj na decyzję
      }

      // Standardowy check naturalnych (gdy nie ma oferty ubezpieczenia)
      const dTotal = handTotals([dealer[0], hiddenDealerCard]);
      if (pTotal === 21 || dTotal === 21){
        hideDealerHole = false;
        renderHand(dealerHandEl, dealer, true);
        updateScores();                 // <— dopisane
        resolveRound(true);
        return;
      }

      state = 'player';
      setMsg('Twoja tura: dobierz (H), stój (S), split (P) lub podwój (D).');
      setControls();
    }

    function hit(){
      if (state !== 'player') return;
      const cur = currentPlayerHand();
      if (handTotals(cur) >= 21) { // nic nie dobieraj gdy 21+
        setControls();
        return;
      }
      cur.push(deck.pop());
      renderPlayer();
      const {p} = updateScores();

      if (p > 21){
        if (!splitActive){
          hideDealerHole = false;
          renderHand(dealerHandEl, dealer, true);
          updateScores();
          resolveRound();
        } else {
          nextSplitHandOrDealer();
        }
      } else if (p === 21) {
        setMsg('Masz 21. Wybierz Stój.');
      } else {
        setMsg(splitActive ? `Ręka ${currentHand+1}: dobierz lub stój.` : 'Dobierz lub stój.');
      }
      setControls();
    }

    // 2) Po odkryciu krupiera – zaktualizuj wynik
    function stand(){
      if (state !== 'player') return;
      if (!splitActive){
        hideDealerHole = false;
        renderHand(dealerHandEl, dealer, true);
        updateScores();                 // <— dopisane
        dealerTurn();
      } else {
        nextSplitHandOrDealer();
      }
    }

    function doubleDown(){
      if (state !== 'player') return;
      if (handTotals(currentPlayerHand()) >= 21) return; // brak podwajania przy 21

      if (!splitActive){
        if (!(player.length === 2 && balance >= bet)) return;
        balance -= bet; bet *= 2; saveBalance(); updateMoney();
        player.push(deck.pop());
        renderPlayer();
        const {p} = updateScores();
        hideDealerHole = false;
        renderHand(dealerHandEl, dealer, true);
        if (p > 21){ resolveRound(); } else { dealerTurn(); }
      } else {
        const cur = currentPlayerHand();
        const curBet = handBets[currentHand];
        if (!(cur.length === 2 && balance >= curBet)) return;
        balance -= curBet; handBets[currentHand] = curBet * 2; saveBalance(); updateMoney();
        cur.push(deck.pop());
        renderPlayer();
        updateScores();
        nextSplitHandOrDealer();
      }
    }

    function nextSplitHandOrDealer(){
      if (!splitActive) return;
      if (currentHand + 1 < playerHands.length){
        currentHand++;
        renderPlayer();
        updateScores();
        setMsg(`Ręka ${currentHand+1}: dobierz (H), stój (S), split (P) lub podwój (D).`);
        setControls();
        return;
      }
      hideDealerHole = false;
      renderHand(dealerHandEl, dealer, true);
      updateScores();                   // <— dopisane
      dealerTurn();
    }

    // Split – podziel bieżącą rękę na dwie, pobierz dodatkowy zakład i dobierz po 1 karcie
    function doSplit(){
      if (!canSplit()) return;

      // Pierwszy split: przenieś pojedynczą rękę do struktury wielu rąk
      if (!splitActive){
        splitActive = true;
        playerHands = [[player[0], player[1]]];
        handBets = [bet];
        player = []; // pojedyncza ręka nieużywana po splicie
        currentHand = 0;
      }

      const baseBet = handBets[currentHand];
      if (balance < baseBet){ setMsg('Za mało środków na split.'); return; }

      // Pobierz dodatkową stawkę na nową rękę
      balance -= baseBet; saveBalance(); updateMoney();

      // Rozdziel obecną rękę na dwie
      const hand = playerHands[currentHand];
      const first = [hand[0]];
      const second = [hand[1]];

      // Podmień w strukturze i duplikuj stawki
      playerHands.splice(currentHand, 1, first, second);
      handBets.splice(currentHand, 1, baseBet, baseBet);

      // Dobierz po jednej karcie do każdej nowej ręki
      first.push(deck.pop());
      second.push(deck.pop());

      // Odśwież UI
      renderPlayer();
      updateScores();
      setMsg(`Split wykonany. Ręka ${currentHand+1} w grze.`);
      setControls();
    }
    // 3) Aktualizuj wynik krupiera przy każdym dociągnięciu
    function dealerTurn(){
      state = 'dealer';
      let d = handTotals(dealer);
      // Krupier dobiera do 17 (H17: dobiera przy miękkim 17)
      while (d < 17){
        dealer.push(deck.pop());
        renderHand(dealerHandEl, dealer, true);
        d = handTotals(dealer);
        updateScores();                 // <— dopisane
      }
      updateScores();                   // <— dopisane
      resolveRound();
    }

    function resolveSplitRound(){
      const d = handTotals(dealer);
      const results = [];
      for (let i=0; i<playerHands.length; i++){
        const p = handTotals(playerHands[i]);
        const wager = handBets[i];
        if (p > 21){
          results.push(`R${i+1}: Bust`);
        } else if (d > 21){
          balance += wager * 2; results.push(`R${i+1}: Wygrana`);
        } else if (p > d){
          balance += wager * 2; results.push(`R${i+1}: Wygrana`);
        } else if (p < d){
          results.push(`R${i+1}: Przegrana`);
        } else {
          balance += wager; results.push(`R${i+1}: Push`);
        }
      }
      saveBalance(); updateMoney();
      state = 'round-over';
      setMsg(results.join(' | '));
      setControls();
    }

    function resolveRound(skipNaturalCheck=false){
      if (splitActive){
        return resolveSplitRound();
      }
      const p = handTotals(player);
      const d = handTotals(dealer);
      state = 'round-over';

      const playerNatural = (player.length === 2 && p === 21);
      const dealerNatural = (dealer.length === 2 && d === 21);

      if (!skipNaturalCheck && playerNatural && dealerNatural){
        // push
        balance += bet; setMsg('Push – oboje macie blackjacka.', 'push');
      } else if (!skipNaturalCheck && playerNatural){
        const win = Math.floor(bet * 2.5);
        balance += win; setMsg(`Blackjack! Wygrana ${win - (bet*1)}.`, 'payout');
      } else if (!skipNaturalCheck && dealerNatural){
        setMsg('Krupier ma blackjacka. Przegrywasz.', 'lose');
      } else if (p > 21){
        setMsg('Przebicie – przegrywasz zakład.', 'lose');
      } else if (d > 21){
        balance += bet*2; setMsg('Krupier przebił – wygrywasz!', 'payout');
      } else if (p > d){
        balance += bet*2; setMsg('Wygrywasz!', 'payout');
      } else if (p < d){
        setMsg('Przegrywasz.', 'lose');
      } else {
        balance += bet; setMsg('Remis – zwrot stawki.', 'push');
      }

      saveBalance(); updateMoney();
      setControls();
    }

    // Decyzje ubezpieczenia
    insYes && insYes.addEventListener('click', function(){
      if (state !== 'insurance') return;
      const half = Math.floor(bet / 2);
      if (half <= 0) return;
      if (balance < half){ setMsg('Za mało środków na ubezpieczenie.'); return; }

      insuranceTaken = true; insuranceBet = half;
      balance -= insuranceBet; saveBalance(); updateMoney();

      // Peek: czy krupier ma blackjacka?
      const dPeek = handTotals([dealer[0], hiddenDealerCard]);
      if (dPeek === 21){
        hideDealerHole = false;
        renderHand(dealerHandEl, dealer, true);
        updateScores();                 // <— dopisane
        balance += insuranceBet * 3; saveBalance(); updateMoney();
        setMsg('Blackjack krupiera. Ubezpieczenie wypłaca 2:1. Runda zakończona.', 'push');
        state = 'round-over';
        showInsurance(false);
        setControls();
      } else {
        showInsurance(false);
        if (handTotals(player) === 21){
          hideDealerHole = false;
          renderHand(dealerHandEl, dealer, true);
          updateScores();               // <— dopisane
          state = 'round-over';
          resolveRound(false);
        } else {
          state = 'player';
          setMsg('Ubezpieczenie przegrane. Twoja tura: dobierz (H) lub stój (S).');
          setControls();
        }
      }
    });

    insNo && insNo.addEventListener('click', function(){
      if (state !== 'insurance') return;
      const dPeek = handTotals([dealer[0], hiddenDealerCard]);
      if (dPeek === 21){
        hideDealerHole = false;
        renderHand(dealerHandEl, dealer, true);
        updateScores();                 // <— dopisane
        resolveRound(true);
      } else {
        showInsurance(false);
        if (handTotals(player) === 21){
          hideDealerHole = false;
          renderHand(dealerHandEl, dealer, true);
          updateScores();               // <— dopisane
          state = 'round-over';
          resolveRound(false);
        } else {
          state = 'player';
          setMsg('Twoja tura: dobierz (H) lub stój (S).');
          setControls();
        }
      }
    });

    // Reset ubezpieczenia przy nowej rundzie
    function newRound(){
      bet = 0; updateMoney();
      state = 'betting';
      insuranceBet = 0; insuranceTaken = false; insuranceOffered = false;
      showInsurance(false);
      splitActive = false; playerHands = null; handBets = null; currentHand = 0;
      setMsg('Ustaw zakład i kliknij Rozdaj.');
      resetHands();
      setControls();
    }

    // Inicjalizacja
    function init(){
      updateMoney();
      resetHands();
      setMsg('Ustaw zakład i kliknij Rozdaj.');

      dealBtn.addEventListener('click', startRound);
      hitBtn.addEventListener('click', hit);
      standBtn.addEventListener('click', stand);
      doubleBtn.addEventListener('click', doubleDown);
      newBtn.addEventListener('click', newRound);
      splitBtn.addEventListener('click', doSplit);

      window.addEventListener('keydown', (e)=>{
        if (state==='player'){
          if (e.key.toLowerCase() === 'h') hit();
          if (e.key.toLowerCase() === 's') stand();
          if (e.key.toLowerCase() === 'd') doubleDown();
          if (e.key.toLowerCase() === 'p') doSplit();
        }
      });

      chips.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          if (state !== 'betting') return;
          if (btn.dataset.add){
            const add = Number(btn.dataset.add);
            if (balance >= bet + add){
              bet += add; updateMoney();
            }
          } else if (btn.dataset.clear){
            bet = 0; updateMoney();
          }
          setControls();
        });
      });

      // Przycisk "Nowa runda" włącza się po zakończeniu
      const observer = new MutationObserver(()=>{
        if (state==='round-over'){
          newBtn.disabled = false;
          hitBtn.disabled = standBtn.disabled = doubleBtn.disabled = true;
        }
      });
      observer.observe(messageEl, {childList:true, subtree:true});

      setControls();
    }

    // Po załadowaniu
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>